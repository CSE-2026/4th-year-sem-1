Here is a Java program that implements a few essential **string algorithms** commonly used for string manipulation, pattern matching, and searching:

### String Algorithms Implementation in Java

The program includes the following string algorithms:

1. **Naive Pattern Matching**
2. **Knuth-Morris-Pratt (KMP) Algorithm**
3. **Rabin-Karp Algorithm**
4. **Longest Common Prefix (LCP)**
5. **String Reversal**

```java
public class StringAlgorithms {

    // 1. Naive Pattern Matching Algorithm
    public static void naivePatternMatching(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();

        // Loop over text and match the pattern
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                System.out.println("Pattern found at index " + i);
            }
        }
    }

    // 2. Knuth-Morris-Pratt (KMP) Algorithm
    private static int[] buildLPSArray(String pattern) {
        int[] lps = new int[pattern.length()];
        int len = 0;
        int i = 1;

        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    public static void kmpPatternMatching(String text, String pattern) {
        int[] lps = buildLPSArray(pattern);
        int i = 0, j = 0;

        while (i < text.length()) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }
            if (j == pattern.length()) {
                System.out.println("Pattern found at index " + (i - j));
                j = lps[j - 1];
            } else if (i < text.length() && pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
    }

    // 3. Rabin-Karp Algorithm
    public static void rabinKarpPatternMatching(String text, String pattern) {
        int d = 256;  // Number of characters in the input alphabet
        int q = 101;  // A prime number
        int m = pattern.length();
        int n = text.length();
        int i, j;
        int p = 0; // Hash value for pattern
        int t = 0; // Hash value for text
        int h = 1;

        // The value of h would be "pow(d, m-1)%q"
        for (i = 0; i < m - 1; i++) {
            h = (h * d) % q;
        }

        // Calculate hash value for pattern and first window of text
        for (i = 0; i < m; i++) {
            p = (d * p + pattern.charAt(i)) % q;
            t = (d * t + text.charAt(i)) % q;
        }

        // Slide the pattern over text one by one
        for (i = 0; i <= n - m; i++) {
            if (p == t) {
                for (j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        break;
                    }
                }
                if (j == m) {
                    System.out.println("Pattern found at index " + i);
                }
            }

            // Calculate hash value for next window of text
            if (i < n - m) {
                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;

                // We might get negative value of t, converting it to positive
                if (t < 0) {
                    t = (t + q);
                }
            }
        }
    }

    // 4. Longest Common Prefix (LCP) Array (for two strings)
    public static int longestCommonPrefix(String s1, String s2) {
        int i = 0;
        while (i < s1.length() && i < s2.length() && s1.charAt(i) == s2.charAt(i)) {
            i++;
        }
        return i;
    }

    // 5. String Reversal
    public static String reverseString(String str) {
        StringBuilder sb = new StringBuilder(str);
        return sb.reverse().toString();
    }

    // Main method to test all the string algorithms
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";

        System.out.println("Naive Pattern Matching:");
        naivePatternMatching(text, pattern);

        System.out.println("\nKnuth-Morris-Pratt (KMP) Pattern Matching:");
        kmpPatternMatching(text, pattern);

        System.out.println("\nRabin-Karp Pattern Matching:");
        rabinKarpPatternMatching(text, pattern);

        // Example for LCP (Longest Common Prefix)
        String str1 = "abcdef";
        String str2 = "abxy";
        System.out.println("\nLongest Common Prefix between '" + str1 + "' and '" + str2 + "': " + longestCommonPrefix(str1, str2));

        // Example for String Reversal
        String str = "Hello, World!";
        System.out.println("\nReversed String of '" + str + "': " + reverseString(str));
    }
}
```

### Explanation of Each Algorithm:

1. **Naive Pattern Matching**:
   - This approach checks all possible positions in the text for the pattern. If it finds a match, it prints the position. The time complexity is **O((n - m + 1) * m)**, where `n` is the length of the text and `m` is the length of the pattern.

2. **Knuth-Morris-Pratt (KMP) Algorithm**:
   - This is an efficient algorithm that preprocesses the pattern to build an **LPS (Longest Prefix Suffix)** array. The LPS array helps in skipping redundant comparisons. The time complexity is **O(n + m)**, where `n` is the length of the text and `m` is the length of the pattern.

3. **Rabin-Karp Algorithm**:
   - This algorithm uses hashing to find the pattern in the text. It computes the hash values of the pattern and the substrings in the text, then compares them. The time complexity is **O(n + m)** on average but can degrade to **O(n * m)** in the worst case.

4. **Longest Common Prefix (LCP)**:
   - This function computes the length of the longest common prefix between two strings. It compares characters at each position until a mismatch is found. The time complexity is **O(min(m, n))**, where `m` and `n` are the lengths of the two strings.

5. **String Reversal**:
   - This function reverses a given string using the `StringBuilder` class. The time complexity is **O(n)**, where `n` is the length of the string.

### Example Output:

```
Naive Pattern Matching:
Pattern found at index 10

Knuth-Morris-Pratt (KMP) Pattern Matching:
Pattern found at index 10

Rabin-Karp Pattern Matching:
Pattern found at index 10

Longest Common Prefix between 'abcdef' and 'abxy': 2

Reversed String of 'Hello, World!': !dlroW ,olleH
```

### Conclusion:
This program demonstrates several important string algorithms, each with different characteristics, trade-offs, and use cases. The KMP and Rabin-Karp algorithms are particularly efficient for pattern matching in large texts, while the Naive approach can still be useful for small strings or when simplicity is desired.
